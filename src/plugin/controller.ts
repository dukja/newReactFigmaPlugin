// Ï†úÏô∏ ÌéòÏù¥ÏßÄÎ™Ö
const excludedPageNames = ['A1', 'A2', '‚ñº', 'C1', 'Container', 'Cover', 'Scroll', 'Ï†úÏûëÏ§ë', 'Heading'];
// Ìè¨Ìï® ÎÖ∏Îìú ÌÉÄÏûÖ
const includedNodeTypes = ['COMPONENT_SET', 'COMPONENT', 'INSTANCE','FRAME'];
// Ï†úÏô∏ ÎÖ∏ÎìúÎ™Ö
const excludedNodeNames = ['example', 'document', 'sample', 'dev', '_', '-dev', 'Guide', 'guide'];
// ÌïÑÌÑ∞Îêú ÌéòÏù¥ÏßÄ
let removePage: any = null;
function getremovePage() {
  if (removePage === null) {
    removePage = figma.root.children.filter((page) => !isExcludedPage(page));
  }
  return removePage;
}

// Ï†úÏô∏ ÌéòÏù¥ÏßÄ
function isExcludedPage(node: any) {
  return node.type === 'PAGE' && excludedPageNames.some((name) => node.name.includes(name));
}
// Ìè¨Ìï® ÎÖ∏Îìú
function isIncludedNode(node: any) {
  return (
    includedNodeTypes.some((type) => node.type.includes(type)) &&
    !excludedNodeNames.some((name) => node.name.includes(name))
  );
}
// Ïä§ÌÉÄÏùº ÎÖ∏Îìú
function getStyledNode(node: any): any {
  let styles = {
    fill: undefined,
    fills: undefined,
    stroke: undefined,
    strokes: undefined,
    effect: undefined,
    font: undefined,
    radius: undefined,
    padding: undefined,
  };
  if ('children' in node) {
    for (let child of node.children) {
      let styledChild = getStyledNode(child);
      if (styles.fill !== undefined && styledChild.fill  ) {
        styles.fill = styledChild.fill;
      }
      if (styles.stroke !== undefined && styledChild.stroke  ) {
        styles.stroke = styledChild.stroke;
      }
      if (styles.fills !== undefined && styledChild.fills && styledChild.fills[0] && styledChild.fills[0].boundVariables && styledChild.fills[0].boundVariables['color'] && styledChild.fills[0].boundVariables['color'].id!== undefined) {
        styles.fills = styledChild.fills
      }  
      if (styles.strokes !== undefined && styledChild.strokes && styledChild.strokes[0] && styledChild.strokes[0].boundVariables && styledChild.strokes[0].boundVariables['color'] && styledChild.strokes[0].boundVariables['color'].id ) {
        styles.strokes = styledChild.strokes
      }  
      if (styles.effect !== undefined && styledChild.effect  ) {
        styles.effect = styledChild.effect;
      }
      if (styles.font !== undefined && styledChild.font) {
        styles.font = styledChild.font;
      }
      if (styles.radius !== undefined && styledChild.topLeftRadius) {
        styles.radius =styledChild.topLeftRadius
      }
      if (styles.padding !== undefined && styledChild.paddingBottom || styledChild.paddingLeft || styledChild.paddingRight||styledChild.paddingTop) {
        styles.padding = styledChild.padding;
      }
    }
  }  
  if (node.fillStyleId) {
    styles.fill = node;
  }
  if (node.strokeStyleId) {
    styles.stroke = node;
  }
  if (node.fills && node.fills[0] && node.fills[0].boundVariables && node.fills[0].boundVariables['color'] && node.fills[0].boundVariables['color'].id) {
    styles.fills = node;
  }  
  if (node.strokes && node.strokes[0] && node.strokes[0].boundVariables && node.strokes[0].boundVariables['color'] && node.strokes[0].boundVariables['color'].id) {
    styles.strokes = node;
  }  
  if (node.effectStyleId) {
    styles.effect = node;
  }
  if ('textStyleId' in node) { 
    styles.font = node;
  }
  if (node.topLeftRadius) {
    styles.radius = node;
  }
  if (node.paddingBottom || node.paddingLeft || node.paddingRight||node.paddingTop) {
    styles.padding = node;
  }


  return styles;
}

// Ïä§ÌÉÄÏùº Ïù¥Î¶Ñ
function getStyleName(styleId: any) {
  if (typeof styleId === 'string') {
    const style = figma.getStyleById(styleId);
    return style ? style.name : null;
  } else {
    // Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ styleId Ï≤òÎ¶¨ (Ïòà: Ïã¨Î≥º ÌÉÄÏûÖÏù∏ Í≤ΩÏö∞)
    return null; // ÎòêÎäî ÏóêÎü¨ Ï≤òÎ¶¨
  }
}

function getInArray (array,item) {
  let getArray = array;
 if(!array.includes(item)){
  getArray = [...array, item];
 }
 return getArray
}

// Ïä§ÌÉÄÏùº Ïù¥Î¶Ñ Ï∂îÍ∞Ä Ìï®Ïàò
const setStyleNameToNodeStyles = (styleId, targetArray) => {
  // ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ïù¥Î¶Ñ
  const styleName = getStyleName(styleId);
  let setArray
  if (styleName) {
     setArray = getInArray(targetArray,styleName); // ÏÉàÎ°úÏö¥ Ïä§ÌÉÄÏùº Ïù¥Î¶Ñ Ï∂îÍ∞Ä (Ï§ëÎ≥µÏùÄ Ï†úÍ±∞Îê®)
  }
  return setArray; // Ï§ëÎ≥µÎêòÎäî Ïä§ÌÉÄÏùº Ïù¥Î¶ÑÏù¥ ÏûàÏúºÎ©¥ Í∑∏ÎÉ• ÌòÑÏû¨ Î∞∞Ïó¥ÏùÑ Î∞òÌôò
};

type NodeStyle = {
  name: string;
  fill: string[];
  stroke: string[];
  fills: string[];
  strokes: string[];
  effect: string[];
  font: string[];
  height: number[];
  radius: number[];
  padding: number[];
  defaultVariant: string | null;
};

type PageNodeInfo = {
  pageName: string;
  nodes: NodeStyle[];
};

// ÎÖ∏Îìú Ï†ïÎ≥¥
let nodesinfos: any[] = []; // Î∞∞Ïó¥Î°ú Ï¥àÍ∏∞Ìôî

// Í∞Å ÌéòÏù¥ÏßÄÏùò ÎÖ∏Îìú Ï†ïÎ≥¥
function getNodeInfo() {
  if (nodesinfos.length > 0) return;
  const removedPage = getremovePage();
  removedPage.forEach((page: any) => {
    //ÌïÑÌÑ∞Îêú ÎÖ∏Îìú
    const removedNode = page.children.filter((node: any) => isIncludedNode(node));
    const nodesinfo: PageNodeInfo = {
      pageName: page.name,
      nodes: [],
    };
    type Node = {
      type: string;
      name: string;
      children?: Node[];
    };

  let newNodesList: Node[] = [];
  removedNode.forEach((node: any) => {
    if(node.type === "FRAME"){
      if(node.name.includes("üö´")){
          if (node.children) {
              newNodesList = [...newNodesList, ...node.children];
          }}
      else{return}
    }else{
        newNodesList = [...newNodesList, node];
    }})
    newNodesList.forEach((node: any) => {
      const nodeInfo = {
        name: node.name,
        fill: [],
        fills: [],
        stroke: [],
        strokes: [],
        effect: [],
        font: [],
        height:[],
        radius:[],
        padding:[],
        defaultVariant: node.defaultVariant ? node.defaultVariant.name : null,
      };
      if ('children' in node) {
        
        node.children.forEach((childNode: any) => {
          //Ïä§ÌÉÄÏùº ÎÖ∏Îìú
          const styleNodes = getStyledNode(childNode);

          //ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ï†ïÎ≥¥
          if (styleNodes.fill) {
            nodeInfo.fill = setStyleNameToNodeStyles(styleNodes.fill.fillStyleId, nodeInfo.fill);
          }
          if (styleNodes.stroke) {
            nodeInfo.stroke = setStyleNameToNodeStyles(styleNodes.stroke.strokeStyleId, nodeInfo.stroke);
          }
          if (styleNodes.fills) {
            if (styleNodes.fills.fills[0]!== undefined && styleNodes.fills.fills[0].boundVariables!== undefined && styleNodes.fills.fills[0].boundVariables['color']!== undefined && styleNodes.fills.fills[0].boundVariables['color'].id !== undefined)  {
              const fills = figma.variables.getVariableById(styleNodes.fills.fills[0].boundVariables['color'].id).name;
              nodeInfo.fills = [...nodeInfo.fills,fills]
            }
          }
          if (styleNodes.strokes) {
            if (styleNodes.strokes.strokes[0]!== undefined && styleNodes.strokes.strokes[0].boundVariables!== undefined && styleNodes.strokes.strokes[0].boundVariables['color'] !== undefined && styleNodes.strokes.strokes[0].boundVariables['color'].id !== undefined) {
              const strokes = figma.variables.getVariableById(styleNodes.strokes.strokes[0].boundVariables['color'].id).name;
              nodeInfo.strokes = [...nodeInfo.strokes,strokes]
            }
          }
          if (styleNodes.effect) {
            nodeInfo.effect = setStyleNameToNodeStyles(styleNodes.effect.effectStyleId, nodeInfo.effect);
          }
          if (styleNodes.font) {
            nodeInfo.font = setStyleNameToNodeStyles(styleNodes.font.textStyleId, nodeInfo.font);
          }
          if (childNode.height) {
            nodeInfo.height = childNode.height
          }      
          if (styleNodes.radius) {
            nodeInfo.radius = styleNodes.radius.topLeftRadius
          }
          if (styleNodes.padding) {
            nodeInfo.padding = styleNodes.padding
          }
        });
        nodesinfo.nodes = [...nodesinfo.nodes, nodeInfo];
      }
    });
    nodesinfos = [...nodesinfos, nodesinfo];
  });
}

// ÏÑ†ÌÉù ÎÖ∏Îìú Ï†ïÎ≥¥
let selectednNodeinfos: any[] = []; // Î∞∞Ïó¥Î°ú Ï¥àÍ∏∞Ìôî
function getSelectedNodeInfo(selectednNodes: any) {
  const selectednNodeinfo = {
    name: [],
    fill: [],
    fills: [],
    stroke: [],
    strokes: [],
    effect: [],
    font: [],
    height: [],
    radius: [],
    padding: [],
    defaultVariant: selectednNodes.defaultVariant ? selectednNodes.defaultVariant.name : null,
  };
  console.log('selectednNodes',selectednNodes)
  selectednNodes.forEach((selectednNode)=>{
    if ('children' in selectednNode) {
      selectednNode.children.forEach((childNode: any) => {
        //Ïä§ÌÉÄÏùº ÎÖ∏Îìú
        const styleNodes = getStyledNode(childNode);
        
        //ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ï†ïÎ≥¥
        if (selectednNode.name) {
          selectednNodeinfo.name = selectednNode.parent.type !== 'PAGE'? getInArray(selectednNodeinfo.name,selectednNode.parent.name): getInArray(selectednNodeinfo.name,selectednNode.name)
        }
        if (styleNodes.stroke) {
          selectednNodeinfo.stroke = setStyleNameToNodeStyles(styleNodes.stroke.strokeStyleId, selectednNodeinfo.stroke);
        }          
        if (styleNodes.fills) {
          selectednNodeinfo.fills = figma.variables.getVariableById(styleNodes.fills.fills[0].boundVariables['color'].id).name;
        }
        if (styleNodes.strokes) {
          selectednNodeinfo.strokes = figma.variables.getVariableById(styleNodes.strokes.strokes[0].boundVariables['color'].id).name;
        }
        if (styleNodes.effect) {
          selectednNodeinfo.effect = setStyleNameToNodeStyles(styleNodes.effect.effectStyleId, selectednNodeinfo.effect);
        }
        if (styleNodes.font) {
          selectednNodeinfo.font = setStyleNameToNodeStyles(styleNodes.font.textStyleId, selectednNodeinfo.font);
        }
        if (childNode.height) {
          selectednNodeinfo.height = childNode.height;
        }
        if (styleNodes.radius) {
          selectednNodeinfo.radius = [styleNodes.radius.topLeftRadius,styleNodes.radius.topRightRadius,styleNodes.radius.bottomRightRadius,styleNodes.radius.bottomLeftRadius];
        }
        if (styleNodes.padding) {
          selectednNodeinfo.padding = [styleNodes.padding.paddingTop,styleNodes.padding.paddingRight,styleNodes.padding.paddingBottom,styleNodes.padding.paddingLeft];
        }
      });
    }    
    selectednNodeinfos = [...selectednNodeinfos, selectednNodeinfo];
  })


  
}

figma.showUI(__html__, { width: 900, height: 600, title: 'CDS Asset Filter' });

figma.ui.onmessage = (message) => {
  if (message.type === 'request_info') {
    if (nodesinfos.length === 0) {
      getNodeInfo();
    }
  }
  if (message.type === 'open-external-link') {
    figma.notify(`Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Î∂ôÏó¨ÎÑ£Í∏∞`);
  }
  figma.ui.postMessage({
    type: 'get_style',
    nodeStyle: nodesinfos,
  });
  const nodeNames = nodesinfos.map((pc) => ({
    pageName: pc.pageName,
    nodeNames: pc.nodes.map((node: { name: any }) => node.name),
  }));
  figma.ui.postMessage({
    type: 'get_name',
    nodeName: nodeNames,
  });
  if (message.type === 'request_selected') {
    selectednNodeinfos = []
    if (figma.currentPage.selection !== null) {
      getSelectedNodeInfo(figma.currentPage.selection);
    }
  }
  figma.ui.postMessage({
    type: 'get_selected',
    seletedNode: selectednNodeinfos,
  });
};